/**
  *FILE IS GENERATED DON'T MODIFY 
*//**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * Note on: function(window, undefined)
 *
 * The undefined is a normal variable and can be changed simply with
 * undefined = "new value";. So we create a local "undefined" variable
 * that is REALLY undefined. (see jquery source for example in the wild)
 *
 * The window variable is made local for performance reasons.
 * Because when javascipt looks up a variable, it first goes through the
 * local variables until it finds the variable name. When it's not found,
 * javascript goes through the next scope etc. until it filters through the
 * global variables. So if the window variable is made local, javascript
 * can look it up quicker.
 *
 * Source (Nicholas C. Zakas and Jquery)
 *
 */

/**
 * This is a wrapper that our entire sdk goes into. Its written into by
 * a compiler script don't edit this file unless you know what you are doing.
 */

(function(window, undefined) {

  /**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * Entry point into groupit javascript SDK.
 *
 * The entire SDK is wrapped in a closure when compiled so don't let
 * the seemingly global definitions confuse you. They are global to the SDK
 * but not to the app.
 */

//Save references in case of overwrite/no conflict mode
var _G = window.G;
var _isLogging = true;

var G = G || {
  instanceId:null, //(AKA instance-private key)
  appKey:null, //(AKA App Identifier)
  endPoint:null, //AKA Server protocol and hostname

  //TODO migrate these tokens from rest Object to here
  persistenceToken: null,
  appSecret:null,

  init:function(appKey, endPoint, callback) {
    G.appKey = appKey;
    G.endPoint = endPoint;


    //Needs the app key before call
    G.api("/misc/random_hash.json", function(json) {
      G.instanceId = json.hash_digest;
      callback();
    });
  }
  ,

  /**
   * Copy from one object to the specified namespace that is G.<target>.
   * If the namespace target doesn't exist, it will be created automatically.
   *
   * @param target    {Object|String}  the target object to copy into
   * @param source    {Object}         the source object to copy from
   * @param overwrite {Boolean}        indicate if we should overwrite
   * @return {Object} the *same* target object back
   */
  provide: function(target, source, overwrite) {
    return this.copy(
      typeof target == 'string' ? this.create(target) : target,
      source,
      overwrite
      );
  }
  ,
  /**
   * Create a namespaced object.
   *
   * @param name {String} full qualified name ('Util.foo', etc.)
   * @param value {Object} value to set. Default value is {}. [Optional]
   * @return {Object} The created object
   */
  create: function(name, value) {
    var node = G,
      nameParts = name ? name.split('.') : [],
      len = nameParts.length;
    for (var i = 0; i < len; i++) {
      var part = nameParts[i];
      var nso = node[part]; //nso = namespaced object
      if (!nso) { //prevents overriding
        nso = (value && i + 1 == len) ? value : {};
        node[part] = nso;
      }
      node = nso;
    }
    return node;
  }
  ,
  /**
   * Copies things from source into target.
   *
   * @param target    {Object}
   * @param source    {Object}
   * @param overwrite {Boolean}
   * @param transform  {function} [Optional], transformation function for
   *                            each item
   */
  copy: function(target, source, overwrite, transform) {
    for (var key in source) {
      if (overwrite || typeof target[key] === 'undefined') {
        target[key] = transform ? transform(source[key]) : source[key];
      }
    }
    return target;
  },

  deepCopy: function(target, source, overwrite, transform) {
    /*
     * Absolutely critical that copy is called first. That way the tree is
     * copied top down (so the references for sub objects are overridden with
     * our blank copies rather than pointers to the original source
     */
    G.copy(target, source, overwrite, transform);
    for (var key in source) {
      //Null is also a object, but we don't want to copy null as a blank obj
      if (typeof source[key] === 'object' && source[key] != null) {
        target[key] = (source[key] instanceof Array) ? [] : {};
        G.deepCopy(target[key], source[key], overwrite, transform);
      }
    }
    return target
  },

  /**
   * Removes standard groupit bindings from global namespace and
   *   replaces with user supplied alternative.
   *
   * @param altName {String} alternative global reference name
   */
  noConflict: function(altName) {
    //noConflicting with G sets to default
    if (altName == "G") {
      window.G = G;

    }
    else if (altName) {
      window[altName] = G;
      window.G = _G; //replace G with what was G before
    }

    globalName = altName;
    return G;
  }
}
  ;

//Do the proper bindings for the window.
window.G = G;

//SDK reference to itself in the caller's global namespace
var globalName = "G";

/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("args", {
  parse: function(_arguments, mapObject) {
    var parsedArgs = {},
      next = _arguments.shift();

    while (next) {
      var type = typeof(next),
        name = mapObject[type];
      if (!name || parsedArgs[name]) {
        throw("Parsing came across a type: " + type + " that it wasn't expecting");
      }
      parsedArgs[name] = next;
      next = _arguments.shift();
    }
    return parsedArgs;
  }
});

/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

//parts borrowed from the fb connect.js libs
G.provide('Array', {

  // This is native javascript function HOWEVER IE (7) BLOWS
  // and we force its definition here if its not defined
  indexOf: function (array, item) {
    if (array.indexOf) {
      return array.indexOf(item);
    }
    var length = array.length;
    if (length) {
      for (var index = 0; index < length; index++) {
        if (array[index] === item) {
          return index;
        }
      }
    }
    return -1;
  },

  /**
   * Create an array by performing transformation on the items in a source
   * array.
   *
   * @param arr {Array} Source array.
   * @param transform {Function} Transformation function.
   * @return {Array} The transformed array.
   */
  map: function(arr, transform) {
    var ret = [];
    for (var i = 0; i < arr.length; i++) {
      ret.push(transform(arr[i]));
    }
    return ret;
  }

});
/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING fromWidget, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("", {
  newBindableObject: function(obj, shallow, debug) {
    var bindable = new G.BindableObject.Base(debug);
    bindable.extend(obj, shallow);
    return bindable;
  }

});

G.provide("BindableObject", {

  Base:function(debug) {
    var self = this;
    self._listeners = {};
    self._data = {};

    /**
     * Extends the current object with a object or array.
     *
     * If passed a object both the keys and values will be mapped into the
     * bindable object. Setters will fire callbacks on the newly set and
     * defined key/value pairs.
     *
     * Note: Objects may pass a boolean value to determine if deep copy or
     * shallow copying should occur. By default we shallow copy.
     *
     * If passed a array only the setters/getters will be mapped using the
     * values in the array as keys. No callbacks are issued as the data has
     * not changed.
     *
     * @param obj
     * @param shallow
     */
    //Opt into shallow copy for optimization
    this.extend = function(obj, shallow) {
      if (!obj) return;
      if (typeof obj !== "object") throw("Must pass object/array to extend");

      if (obj instanceof Array) {
        G.Array.map(obj, function(val) {
          self.generateGetterSetter(val); //overrides previously existing g&s
          self.generateCallback(val);
        });
      } else {
        //Only generate getters and setters for first level (no deep)
        for (var key in obj) {
          self.generateGetterSetter(key); //overrides previously existing g&s
          self.generateCallback(key);
          self[self.nameConversion(key)](obj[key], shallow); //Extend is just looping through the set methods
        }
      }
    };


    //Takes a bindable object and merges with this one
    this.merge = function(bindableObject){
      for(var key in bindableObject._listeners){
        var listenerArray = bindableObject._listeners[key];
        for(var i in listenerArray){
          self._listeners[key] = self._listeners[key] || [];
          self._listeners[key].push(listenerArray[i]);
        }
      }
      G.copy(self._data, bindableObject._data, true);
      return self;
    };

    //Simply calls all the event handlers in the system. Useful when the handlers
    //are disabled and the client wants to get caught up with the current state
    this.flush = function() {
      for (var key in self._data) {
        fireOnKey(key);
      }
    };

    //Nice to get at the raw data without all the getter calls.
    this.data = function() {
      return G.deepCopy({}, self._data, true);
    };

    //Dumps to console if possible
    this.dump = function() {
      G.log(self._data);
      G.log(self._listeners);
    };

    //Overridable method to create a different interface without changing the
    //underlying data
    this.nameConversion = function(name) {
      return name;
    };

    this.callbackName = function(name) {
      name = self.nameConversion(name);
      return "on" + name[0].toUpperCase() + name.slice(1);
    };

    this.generateCallback = function(name) {
      var keyName = self.callbackName(name);
      self[keyName] = function(fn, remove) {
        self._listeners[name] = self._listeners[name] || [];
        if (remove) {
          for(var i in self._listeners[name]){
            var fn2 = self._listeners[name][i];
            if(fn2.toString() == fn.toString()){
              self._listeners[name].splice(i, 1);
              G.log("removing");
            }
          }
        } else {
          self[keyName](fn, true); //Ensure no duplicates are possible.
          self._listeners[name].push(fn);
        }
      }
    };

    this.generateGetterSetter = function (name) {
      self[this.nameConversion(name)] = function() {
        var args = Array.prototype.slice.call(arguments);
        if (args.length == 0) {
          return self._data[name];
        } else {
          var value = args.shift(),
            deep = args.shift();
          return set(name, value, deep);
        }
      };
    };

    function fireOnKey(key) {
      self._listeners[key] = self._listeners[key] || [];
      for (var i in self._listeners[key]) {
        if (self._listeners[key][i]) {
          if (debug) G.log("--Event Listener on key: " + key + " Fired--");
          self._listeners[key][i](self._data[key]);
        }
      }
    }

    //Deep copy is non trivial and in some circumstances doesn't work as expected
    //if you need a deep copy you can ask for one
    function set(key, value, deep) {
      self._listeners[key] = self._listeners[key] || [];
      //Null's type is "object"... doh
      if (deep && typeof value === 'object' && value != null) {
        var empty = (value instanceof Array) ? [] : {};
        self._data[key] = G.deepCopy(empty, value, true)
      } else {
        self._data[key] = value;
      }

      fireOnKey(key);
      return self._data[key];
    }

  }

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

//Taken from http://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx
G.provide("browser", {

  // Returns the version of Internet Explorer or a -1
  // (indicating the use of another browser).
  ieVersion: function() {
    var rv = -1; // Return value assumes failure.
    if (navigator.appName == 'Microsoft Internet Explorer') {
      var ua = navigator.userAgent;
      var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
      if (re.exec(ua) != null)
        rv = parseFloat(RegExp.$1);
    }
    return rv;
  }

})/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

// heavily leveraging http://www.askapache.com/javascript/my-favorite-javascript-2007.html
G.provide("cookie", {

  getExpDate: function (days, hours, minutes) {
    var expDate = new Date();
    if (typeof days == "number" && typeof hours == "number" && typeof hours == "number") {
      expDate.setDate(expDate.getDate() + parseInt(days));
      expDate.setHours(expDate.getHours() + parseInt(hours));
      expDate.setMinutes(expDate.getMinutes() + parseInt(minutes));
      return expDate.toGMTString();
    } else return "";
  },

  getCookie: function (name) {
    var arg = name + "=";
    var alen = arg.length;
    var clen = document.cookie.length;
    var i = 0;
    while (i < clen) {
      var j = i + alen;
      if (document.cookie.substring(i, j) == arg) return getCookieVal(j);
      i = document.cookie.indexOf(" ", i) + 1;
      if (i == 0)break;
    }
    return "";


    function getCookieVal(offset) {
      var endstr = document.cookie.indexOf(";", offset);
      if (endstr == -1) endstr = document.cookie.length;
      return decodeURIComponent(document.cookie.substring(offset, endstr));
    }

  },

  setCookie: function (name, value, expires, path, domain, secure) {
    document.cookie = name + "=" + encodeURIComponent(value) +
      ((expires) ? "; expires=" + expires : "") +
      ((path) ? "; path=" + path : "") +
      ((domain) ? "; domain=" + domain : "") +
      ((secure) ? "; secure" : "");
  },

  deleteCookie: function (name, path, domain) {
    if (G.cookie.getCookie(name)) {
      document.cookie = name + "=" + ((path) ? "; path=" + path : "") +
        ((domain) ? "; domain=" + domain : "") +
        "; expires=Thu, 01-Jan-70 00:00:01 GMT";
    }
  }


});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("Date", {
  /**
   * I hate those lazy javascript core developers that didn't bake this in.
   */

  //Taken from here: http://www.pelagodesign.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/
  isIso8601Date:function(string) {
    if (!string) return false;
    return string.match(/^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/);
  },

  //Taken from last example on: https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference:Global_Objects:Date
  iso8601DateString:function(date) {
    function pad(n) {
      return n < 10 ? '0' + n : n
    }

    return date.getUTCFullYear() + '-'
      + pad(date.getUTCMonth() + 1) + '-'
      + pad(date.getUTCDate()) + 'T'
      + pad(date.getUTCHours()) + ':'
      + pad(date.getUTCMinutes()) + ':'
      + pad(date.getUTCSeconds()) + 'Z'
  },

  /**
 * Date.parse with progressive enhancement for ISO-8601, version 2
 * Â© 2010 Colin Snover <http://zetafleet.com>
 * Released under MIT license.
 */
  iso8601DateParse: function(date){
    var timestamp, minutesOffset = 0, struct;
    if ((struct = /^(\d{4}|[+\-]\d{6})-(\d{2})-(\d{2})(?:[T ](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?))?/.exec(date))) {
      if (struct[8] !== 'Z') {
        minutesOffset = +struct[10] * 60 + (+struct[11]);
        if (struct[9] === '+') {
          minutesOffset = 0 - minutesOffset;
        }
      }
      timestamp = new Date(+struct[1], +struct[2] - 1, +struct[3], +struct[4], +struct[5] + minutesOffset, +struct[6], +struct[7].substr(0, 3));
    }

    return timestamp;
  }

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 */


G.provide("", {
  /**
   * addEvent
   *
   * Adds a eventhandler to the specified event without overriding previously
   * defined eventhanders.
   *
   * @param object      {Object}         object to watch for the event
   * @param eventType   {String}         event type (eg click, load, blur)
   * @param eventHandler {Function}       function to handle the event
   */
  addEvent:function(object, eventType, eventHandler) {
    G.eventManager.addEvent.call(G.eventManager, object, eventType, eventHandler);
  },

  /**
   * removeEvent
   *
   * Removes a eventhandler to the specified event without overriding previously
   * defined eventhanders. Must match the AddEvent call exactly
   *
   * @param object      {Object}         object to attach the event to
   * @param eventType   {String}         event type (eg click, load, blur)
   * @param eventHandler {Function}       function to handle the event
   */

  removeEvent:function(object, eventType, eventHandler) {
    G.eventManager.removeEvent.call(G.eventManager, object, eventType, eventHandler);
  }

});

// AddEvent and removeEvent Taken from John Resig
G.provide("eventManager", {
  addEvent:function(obj, type, fn) {
    if (obj.attachEvent) {
      obj['e' + type + fn] = fn;
      obj[type + fn] = function() {
        obj['e' + type + fn](window.event);
      };
      obj.attachEvent('on' + type, obj[type + fn]);
    }
    else {
      obj.addEventListener(type, fn, false);
    }
  },

  removeEvent: function(obj, type, fn) {
    if (obj.detachEvent) {
      if(!obj[type + fn]) return; //don't detach something that doesn't exist
      obj.detachEvent('on' + type, obj[type + fn]);
      obj[type + fn] = null;
    }
    else {
      obj.removeEventListener(type, fn, false);
    }
  }

});

/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("", {

  initialize:function(appKey, endPoint, callback) {
    //Construct our rails models and api objects
    G.DataObject.init();

    //Begin routing observation of the window bar
    G.router.init();

    //Sets our endpoint (ie where we send api requests)
    //Setup our tokens and keys for this G instance
    G.init(appKey, endPoint, function() {
      callback();
    });
  }
});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("", {

  log:function(message) {
    if (window.console) {
      window.console.log(message);
    }
  }
});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @provides G.api G.ApiClient
 * @requires G.provide G.Array
 *
 */

G.provide("QS", {
  /**
   * Encode parameters to a query string.
   *
   * @access private
   * @param   params {Object}  the parameters to encode
   * @param   sep    {String}  the separator string (defaults to '&')
   * @param   encode {Boolean} indicate if the key/value should be URI encoded
   * @return        {String}  the query string
   */
  encode: function(params, seperator, encode) {
    seperator = seperator === undefined ? '&' : seperator;
    encode = encode === false ? function(s) {
      return s;
    } : encodeURIComponent;

    var kvPairs = [];
    for (var key in params) {
      var val = params[key];
      if (val !== null && typeof val != 'undefined') {
        kvPairs.push(encode(key) + '=' + encode(val));
      }
    }
    kvPairs.sort();
    return kvPairs.join(seperator);
  },

  /**
   * Encode parameters to a query string. Handles nested objects by with rails
   * style bracket notation
   *
   * @access private
   * @param   params {Object}  the parameters to encode
   * @param   seperator {String}  the separator string (defaults to '&')
   * @param   encode {Boolean} indicate if the key/value should be URI encoded
   * @return        {String}  the query string
   */
  nestedEncode: function(params, seperator, encode) {
    seperator = seperator === undefined ? '&' : seperator;
    encode = encode === false ? function(s) {
      return s;
    } : encodeURIComponent;

    //Bracket nested objects
    function deepCall(prefix, params, array) {
      for (var key in params) {
        var val = params[key],
          type = typeof val;
        if (val !== null && type !== 'undefined' && type === 'object'
          && !(val instanceof Array)) {
          deepCall(prefix + "[" + key + "]", val, array);
        }
        else {
          array.push(encode(prefix + "[" + key + "]") + "=" + encode(val));
        }
      }
    }

    var kvPairs = [];
    for (var key in params) {
      var val = params[key],
        type = typeof val;
      if (val !== null && type !== 'undefined' && type === 'object'
        && !(val instanceof Array)) {
        deepCall(key, val, kvPairs);
        continue;
      }
      kvPairs.push(encode(key) + "=" + encode(val));
    }
    kvPairs.sort();
    return kvPairs.join(seperator);
  }


});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("String", {

  toCamelCase: function(string) {
    var newString = String(string);
    var re = /(_)([a-z].*?)/gi,
      matchResult = re.exec(newString);
    while (matchResult) {
      if (matchResult[2]) {
        newString = newString.replace(matchResult[0], matchResult[2].toUpperCase())
      }
      matchResult = re.exec();
    }
    return newString
  },

  toUnderscore: function(string) {
    if (!string) return string;
    return string.replace(/([A-Z])/g, function($1) {
      return "_" + $1.toLowerCase();
    });
  },
  
  reverse: function(s) {
    return s.split("").reverse().join("");
  }

});
/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @provides G.api G.ApiClient
 * @requires G.provide G.Array
 *
 */

G.provide('', {

  //Indirection method for the api calls. Can expand out
  //for richer debugging support, etc
  api: function() {
    G.ApiClient.rest.apply(G.ApiClient, arguments);
  },

  //Allows for posting of forms to remote destinations
  postViaForm: function(path, method, params, fullPath) {
    G.ApiClient.remotePost(path, method, params, fullPath);
  }

});

G.provide('ApiClient', {
  REST_METHODS: ['get', 'post','delete', 'put'],

  /**
   *   rest: REST access to our server with various calling options.
   *
   *   Except for the path all the arguments to this function are
   *   optional. Below are examples of valid invocations.
   *
   *  G.api('gift/delete'); // throw away the response
   *  G.api('gift/delete'), function(r){console.log(r)});
   *  G.api('gift/show'), { param1: 'value1', ... }); //throw away response
   *  G.api('gift', 'put', function(r){ console.log(r) });
   *  G.api(
   *    'gift/create',
   *    'post',
   *    {param1: value1, param2 : value2, ...},
   *    function(r) { console.log(r) }
   *
   * @access private
   * @param path      {String}   the url path
   * @param method    {String}   the http method
   * @param params    {Object}   the parameters for the query
   * @param cb        {Function} the callback function for the response
   */

  rest: function() {
    var
      args = Array.prototype.slice.call(arguments),
      path = args.shift(),
      next = args.shift(),
      method, params, cb, doCors;

    while (next) {
      var type = typeof next;
      if (type === 'string' && !method) {
        method = next.toLowerCase();
      } else if (type === 'function' && !cb) {
        cb = next;
      } else if (type === 'object' && !params) {
        params = next;
      } else {
        G.log('Invalid argument passed to G.api(): ' + next);
        return;
      }
      next = args.shift();
    }


    method = method || 'get';
    params = params || {};


    // remove prefix slash if one is given, as it's already in the base url
    if (path[0] === '/') {
      path = path.substr(1);
    }

    if (G.Array.indexOf(G.ApiClient.REST_METHODS, method) < 0) {
      G.log('failed on rest methods');
      return; //Need to create a logging mech
    }
    G.ApiClient.corsRequest(path, method, params, cb);

    //    var form = G.ApiClient.createForm(path, method, params);

    //    G.ApiClient.iframeRequest(form, cb);
  },

  corsRequest:function(path, method, params, cb) {
    method = method.toLowerCase(); //std ize the method

    //Translate all RESTful actions to post and get (ie8 and other browsers)
    if (method == 'put') {
      method = 'post';
      params["_method"] = 'put';
    } else if (method == 'delete') {
      method = 'get';
      params['_method'] = 'delete';
    }

    params['__timestamp__'] = (new Date()).toString(); //Attempt to cache bust ie
    
    //Construct the url
    var url = G.endPoint + path;
    var queryString = G.QS.encode(params); //nestedEncode(params)
    if (method == 'get') {
      url += "?" + queryString;
    }

    //Setup the XHR
    var xhr = new XMLHttpRequest();

    if ("withCredentials" in xhr) {
      xhr.open(method, url, true);
    } else if (typeof XDomainRequest != "undefined") {
      xhr = new XDomainRequest();
      xhr.open(method, url);
    } else {
      throw("corsRequest: cross site xhr not available");
    }



    //The callback
    if (cb) {
      xhr.onload = function() {
        //Custom contentType and standardization of response
        //TODO this goes into our custom XHR object
        if (!xhr.contentType) {
          if (xhr.getResponseHeader) {
            xhr.contentType = xhr.getResponseHeader("Content-Type");
          }
        }

        var contentType = typeof xhr.contentType == 'string' ? xhr.contentType.toLowerCase() : "";
        var response = xhr.responseText;

        //TODO need to parse the json better than with evals.
        //TODO response replace /*s/ is just to fail here if head was called in rails...
        if (contentType.indexOf("application/json") != -1 && response.replace(/\s*/, "")) {
          eval('response = ' + "(" + response + ")"); //ie needs braces
        }

        //For cool kids
        if (xhr.status) {
          //Set flags in xhr denoting success and errors
          xhr.success = !!xhr.status.toString().match(/^2../);
          xhr.clientError = !!xhr.status.toString().match(/^4../);
          xhr.serverError = !!xhr.status.toString().match(/^5../);
        } else { //FUCK YOU IE!!! TODO move to custom xhr object
          xhr.success = !!xhr.responseText;
          xhr.clientError = xhr.serverError = !xhr.responseText;
        }
        cb(response, xhr);
      };
      //TODO need to handle the error function for ie
      xhr.onerror = xhr.onload;
    }

    if (method == "get") {
      xhr.send();
    } else {
      //IE 8 doesn't support header
      if (xhr.setRequestHeader) {
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      }
      xhr.send(queryString);
    }

  },

  nonCorsDispatch:function(path, method, params, cb) {
    if (method === 'post') {
      var form = G.ApiClient.createForm(path, method, params);
    }

  },

  /**
   * Does a post to a remote location, handles iframe, and form for you.
   * 
   * @param path
   * @param method
   * @param params
   * @param fullPath
   */
  remotePost: function(path, method, params, fullPath) {
    var iframe = G.ApiClient.createHiddenIframe(function(iframe, doc) {
      var form = G.ApiClient.createForm(path, method, params, fullPath, doc);
      if (form) {
        doc.body.appendChild(form);
        form.submit();
      }
    });

    //30 seconds from now clean out that iframe
    setTimeout(function() {
      if (iframe.parentNode)
        iframe.parentNode.removeChild(iframe)
    }, 30000);

  },

  createHiddenIframe: function(callback){
    var iframe = document.createElement('iframe');
    iframe.style.position = "absolute";
    iframe.style.top = "-10000px";
    iframe.style.height = "0px";
    iframe.style.width = "0px";

    //initializes iframe
    document.body.appendChild(iframe);
    var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.close();
    if (callback) callback(iframe, iframeDocument);

    return iframe;
  },

  /**
   *  createForm: Creates a form to submit as a substitute for XHRs.
   *
   * @access private
   * @param path      {String}   the url path
   * @param method    {String}   the http method
   * @param params    {Object}   the parameters for the query
   * @param fullPath  {Boolean}  If the path is a fullpath to a resource
   * @param doc  {Object}[Opt]   A document where the form should be created in
   *
   */

  createForm:function(path, method, params, fullPath, doc) {
    doc = doc || document;
    var form = doc.createElement('form');

    form.action = (fullPath) ? path : G.endPoint + path;

    form.enctype = "multipart/form-data";
    form.method = method;

    for (var key in params) {
      var input = doc.createElement('input');
      input.type ="hidden"; //'hidden'; //DEBUG text
      input.name = key;
      input.value = params[key];
      form.appendChild(input);
    }

    return form;
  }
});
/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */


/**
 * Definition - Chainable Function:
 *   A Chainable function must define a callback function it calls when it
 *   is finished processing. The generic signiture that a Chainable Function
 *   must adhere to is: fn(callback) or fn(params_for_fn, callback);
 *   That callback function must be called for the chain to continue firing
 */

G.provide("", {

  newFnChain:function() {
    return new G.FnChain.Base();
  }
});

G.provide("FnChain", {

  Base:function() {
    var chain = [];


    /**
     * Push a Chainable Function onto the chain queue
     *
     * @param fn       {Function}           A chainable function to be
     *                                        pushed on the queue
     * @param params   {Array}[Optional]    Array of params
     *                                        for the chainable function
     * @param callback {Function}[Optional] Callback called after this link
     *
     */
    this.push = function() {
      var args = Array.prototype.slice.call(arguments),
        fn = args.shift(),
        next = args.shift(),
        params = null,
        callback = null;

      while (next) {
        var type = typeof next;
        if (type === 'function' && !callback) {
          callback = next;
        } else if (next instanceof Array && !params) {
          params = next;
        } else {
          throw('Invalid argument passed to FnChain.push(): ' + next);
        }
        next = args.shift();
      }

      var link = {
        fn:fn,
        params:params,
        callback:callback
      };

      chain.push(link);

      return this; //Makes push chainable (in the jquery sense)
    };

    /**
     * Pushes a function that isn't a "chainable function" by wrapping it
     * in a generic chainable function.
     *
     * @param fn
     */
    this.pushNc = function(fn, params) {

      function correctedFn(callback) {
        if (params) {
          fn.apply(this, params);
        } else {
          fn();
        }
        callback();
      }

      this.push(correctedFn);
      return this;
    };

    /**
     * Sequentially fire the functions and callbacks in the chain FIFO.
     */
    this.fire = function() {
      if (chain.length <= 0) return;

      var link = chain.shift(), callee = arguments.callee;
      if (link.params) {
        //Copying the params allows the chain to be fired again without side effects
        var tempParams = [];
        G.copy(tempParams, link.params);
        tempParams.push(modifiedCallback);
        link.fn.apply(this, tempParams);
      }
      else {
        link.fn(modifiedCallback);
      }

      function modifiedCallback() {
        if (link.callback) {
          link.callback.apply(this, arguments);
        }
        callee();
      }
    }

    this.clear = function() {
      chain = [];
    }
  }

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * This module is the successor to the restObject.
 * Note:the G level methods are injected at G initialization in the init method
 */

G.provide("", {

  newDataObject: function(objectPath, objectName, constructorFn, keys) {
    var bo = G.newBindableObject();
    G.DataObject.Base.prototype = bo;

    //TODO Overridden name conversion... don't like this feel
    bo.nameConversion = function(name) {
      return G.String.toCamelCase(name);
    };

    var base = new G.DataObject.Base(objectPath, objectName, constructorFn);
    //overridden methods work here
    base.extend(keys);
    return base;
  }

});

//Extension of the Bindable Object
G.provide("DataObject", {

  apiObjects: {
    payment_response: {
      path: "/payment_responses",
      keys:["user_id", "groupit_id", "ip_address", "success", "response",
        "is_public", "id","created_at", "updated_at"]
    },
    //TODO need to create the user attribute everywhere and remove from groupit index
    participant: {
      path: "/participants",
      //TODO need to do inverntory on keys (organizer, ... etc)
      keys: ["groupit_id", "contacted", "is_public", "user_id", "id",
        "created_at", "updated_at", "invited", "organizer", "contributor"]
    },
    invitee: { //TODO this is a index action... facades ugh
      path: "/invitees",
      keys: []
    },
    note: {
      path:"/notes",
      keys: ["note", "metadata_id", "metadata_type", "is_public", "user_id",
        "id", "created_at", "updated_at", "name"]
    },
    feed_post: {
      path:"/feed_posts",
      keys: ["message", "groupit_id", "is_public", "user_id", "id",
        "created_at", "updated_at"]
    },
    authentication: {
      path: "/authentications",
      keys: ["user_id", "provider", "uid", "is_public", "id",
        "created_at", "updated_at"]
    },
    app: {
      path: "/apps",
      keys: ["name", "user_id", "is_public", "id", "created_at", "updated_at"]
    },
    address: {
      path: "/addresses",
      keys: ["fullname", "line1", "line2", "city", "state", "zip", "country",
        "phone_number", "user_id", "is_public", "id", "created_at",
        "updated_at"]
    }
  },

  defaultRequestType: ".json",

  /**
   * Common constructor for all our api objects.
   *
   * Namespace must include a restful path, a objectName, the keys available
   * in underscore type, and a Base constructor fn
   *
   * @param namespace {Object}
   * @param constructorFn {Function} the wrapper function that calls this fn.
   * @param json
   */
  commonConstructor: function(namespace, constructorFn, json) {
    var ns = namespace;
    var dataObj = G.newDataObject(ns.path, ns.objectName, constructorFn, ns.keys);
    ns.Base.prototype = dataObj;
    var base = new ns.Base();
    if (json) base.extend(json);
    return base;
  },

  commonIndex: function(config, namespace, constructorFn, params, callback) {
    config = config || {};
    params = params || {};
    var path = namespace.path + G.DataObject.defaultRequestType,
      name = namespace.objectName;

    //Converts the camel cased names to underscores for the server
    for (var key in config.params) {
      params[G.String.toUnderscore(key)] = config.params[key];
    }
    params = G.dogfort.injectRailsParams(params);

    G.api(path, "get", params, function(json, xhr) {
      if (xhr.success) {
        var models = [];
        for (var i in json) {
          //TODO need to do a proper strip namespace
          models.push(constructorFn(json[i][name]));
        }
        callback(models);
        if (config.success) config.success(models, xhr);
      } else {
        if (config.error) config.error(json, xhr);
      }
      if (config.complete) config.complete(json, xhr);
    });
  },

  init: function() {
    //Injecting the api object constructors into the G namespace
    for (var key in G.DataObject.apiObjects) {
      (function() { //Done for the function declarations inside
        var name = key,
          path = G.DataObject.apiObjects[name].path,
          keys = G.DataObject.apiObjects[name].keys;

        //Fixup the constructor name
        var camelCased = G.String.toCamelCase(name),
          capName = camelCased[0].toUpperCase() + camelCased.slice(1),
          constructorName = "new" + capName;

        //Define the constructor
        G[constructorName] = function(json) {
          var base = G.newDataObject(path, name, G[constructorName], keys);
          //overridden methods work here
          if (json) base.extend(json);
          return base;
        };


        /**
         * Config object is a hash. We currently support the following keys
         *
         * success
         * error
         * complete
         * offset
         * limit
         *
         * @param config
         */
        G[capName] = G[capName] || {};
        G[capName].index = function(config) {
          config = config || {};
          var params = {};
          //Converts the camel cased names to underscores for the server
          for (var key in config.params) {
            params[G.String.toUnderscore(key)] = config.params[key];
          }

          params = G.dogfort.injectRailsParams(params);
          //TODO path need to be cleaned up
          G.api(path + ".json", "get", params, function(json, xhr) {
            if (xhr.success) {
              var models = [];
              for (var i in json) {
                //TODO need to do a proper strip namespace
                models.push(G[constructorName](json[i][name]));
              }
              if (config.success) config.success(models, xhr);
            } else {
              if (config.error) config.error(json, xhr);
            }
            if (config.complete) config.complete(json, xhr);
          });
        }
      })();
    }
  },

  Base: function(objectPath, objectName, constructorFn) {
    var self = this;
    self.requestType = G.DataObject.defaultRequestType;
    self.objectPath = objectPath;
    self.objectName = objectName;
    self.constructorFn = constructorFn;

    //--------------------------------------------- API CALLS

    /**
     * Create takes a hash of configuration options
     *
     * success, error, complete are supported
     *
     * @param config
     */

    self.create = function(config) {
      config = config || {};
      var path = objectPath + self.requestType;
      var params = self.data();
      params = self.railify(params);
      if (config.params) G.copy(params, config.params, true); //TODO need to convert to underscore!
      params = G.dogfort.injectRailsParams(params);
      G.api(path, "post", params, function(json, xhr) {
        if (xhr.success) {
          self.extend(self.stripNamespace(json));
          if (config.success) config.success(self, xhr);
        } else {
          if (config.error) config.error(json, xhr);
        }
        if (config.complete) config.complete(json, xhr);
      });
    };

    /**
     * Base Read call for all RestObject Objects
     * Automatically pulls out a singular object from the json response
     *
     * Undefined is the key word to bypass id based lookup and fallback to
     * other methods like hashes
     */
    self.read = function(config) {
      config = config || {};
      var params = self.data(),
        path = objectPath + "/" + (params.id || "undefined") + self.requestType;

      params = self.railify(params);
      params = G.dogfort.injectRailsParams(params);
      G.api(path, "get", params, function(json, xhr) {
        if (xhr.success) {
          self.extend(self.stripNamespace(json));
          if (config.success) config.success(self, xhr);
        } else {
          if (config.error) config.error(json, xhr);
        }
        if (config.complete) config.complete(json, xhr);
      });
    };

    /**
     * Base Update call for all RestObject Objects.
     * Per rails convention this call updates and doesn't return the updated model
     *
     * Undefined is the key word to bypass id based lookup and fallback to
     * other methods like hashes
     */
    self.update = function(config) {
      config = config || {};
      var params = self.data(),
        path = objectPath + "/" + (params.id || "undefined") + self.requestType;

      params = self.railify(params);
      params = G.dogfort.injectRailsParams(params);
      G.api(path, "put", params, function(json, xhr) {
        if (xhr.success) {
          //Update doesn't return the object
          if (config.success) config.success(json, xhr);
        } else {
          if (config.error) config.error(json, xhr);
        }
        if (config.complete) config.complete(json, xhr);
      });
    };
    /**
     * Base Destroy call for all RestObject Objects
     *
     * Undefined is the key word to bypass id based lookup and fallback to
     * other methods like hashes
     */
    self.destroy = function(config) {
      config = config || {};
      var params = self.data(),
        path = objectPath + "/" + (params.id || "undefined") + self.requestType;

      params = self.railify(params);
      params = G.dogfort.injectRailsParams(params);
      G.api(path, "delete", params, function(json, xhr) {
        if (xhr.success) {
          //Destroy doesn't return the object
          if (config.success) config.success(json, xhr);
        } else {
          if (config.error) config.error(json, xhr);
        }
        if (config.complete) config.complete(json, xhr);
      });
    };

    /**
     * Rails uses a bracket notation to namespace key-value pairs relating
     * to a model. Example : user[:id] where user is the model name and id is
     * the attribute to be sent to the server.
     */
    self.railify = function(params) {
      var rails_params = {};
      for (var key in params) {
        if (key == "id") continue;
        if (key == "poll_ticket") {
          rails_params[key] = params[key];
          continue;// Need to do a better job here
        }
        rails_params[objectName + "[" + key + "]"] = params[key];
      }
      return rails_params;
    };

    self.stripNamespace = function(json) {
      return json[self.objectName];
    };
  }

});

























/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * Basic support for communicating with dogfort! Injection of params and
 * stripping json wrappers.
 *
 */

G.provide("dogfort", {

  /**
   * Injects the session token and app key into the params passed in.
   * @param params {Object} Params going to the server without auth tokens
   * TODO should be renamed to framework params
   */
  injectRailsParams: function(params) {
    params = params || {};

    //Set the token only if we have one and the client didn't set it
    if (!params["user[persistence_token]"] && G.persistenceToken) {
      params["user[persistence_token]"] = G.persistenceToken;
    }

    params['app_key'] = G.appKey;

    //Should only be used while testing
    if (G.appSecret)
      params['app_secret'] = G.appSecret;

    if (params['app_secret'] && !G.appSecret)
      throw "App secret not set using G.RestObject.appSecret";

    return params;
  },

  /**
   * Adds specific association includes to the request
   * @param params
   * @param includes {Object}
   */
  injectIncludes: function(params, includes){


//    params.includes =
//    for(var key in para)
    
  },

  //TODO this isn't used yet, is it needed?
  injectPollTicket: function(params, pollTicket) {
    params.poll_ticket = pollTicket;
    return params;
  }

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("", {

  newContribution: function(json) {
    var namespace = G.models.contribution;
    return G.DataObject.commonConstructor(namespace, G.newContribution, json);
  }

});

G.provide("models.contribution", {

  objectName: "contribution",
  path: "/contributions",
  keys: ["groupit_id", "address_id", "amount", "user_id",
    "transaction_id", "surcharge", "payment_response_id", "app_key",
    "is_public", "id", "created_at", "updated_at"],


  /**
   * Base constructor function for the contribution model
   */
  Base:function() {
    var self = this;

    this.create = function(config) {
      config = config || {};
      var params = config.params, //TODO need to either add new keys and admit facade or make exception
        newParams = G.dogfort.injectRailsParams({}),
        pollTicket = G.polling.uniqueTicket();

      G.copy(params, self.data()); //Copy the data from self

      //Get the contribution settings
      G.api("/contributions/new.json", "get", newParams, function(json) {
        var brainTreeUrl = json.url,
          tr_data = json.tr_data;

        params = G.dogfort.injectRailsParams(params);
        var braintreeFormParams = self.braintreeParams(tr_data, pollTicket, params);

//        G.log(braintreeFormParams) //Great little debug line

        //Post the contribution to braintree
        G.postViaForm(brainTreeUrl, "post", braintreeFormParams, true);

        //Initialize the polling mechanism to look for the response on the server
        var pollingParams = self.injectPollTicket({}, pollTicket);
        pollForResponse(pollingParams, 0, config);
      });


    };

    function pollForResponse(requestParams, attempts, config) {
      self.pollOnce(requestParams, function(json, xhr) {

        //TODO typeof is a slight hack for ie8's stupid XDR
        var loaded = (xhr.status == "200" || typeof json === 'object'),
          waiting = (xhr.status == "204" || typeof json === 'string');

        if (attempts > 20) { // 20 * .15 = 30 seconds
          var hash = {
            error:{
              message: "After " + attempts + " attempts no contribution was found"
            }
          };
          if (config.error) config.error(hash, xhr);
          if (config.complete) config.complete(hash, xhr);
        } else if (waiting) {//No content means still looking
          continuePolling(1500);
        } else if (loaded) { //JSON should be loaded
          self.extend(json); //namespace stripped in pollOnce
          if (config.success) config.success(self, xhr);
          if (config.complete) config.complete(json, xhr);
        } else {
          if (config.error) config.error(json, xhr);
          if (config.complete) config.complete(json, xhr);
          G.log("Polling returned a unexpected status:" + xhr.status);
        }

        function continuePolling(timeout) {
          setTimeout(function() {
            pollForResponse(requestParams, attempts + 1, config);
          }, timeout);
        }
      });
    }


    //TODO eventually all models will have polling support for ie 7
    //Is intended only for framework polling
    this.pollOnce = function(params, callback) {
      var path = self.objectPath + "/poll" + self.requestType;
      params = G.dogfort.injectRailsParams(params);
      G.api(path, "get", params, function(json, xhr) {
        if (xhr.success) json = self.stripNamespace(json);
        if (callback) callback(json, xhr);
      });
    };

    this.injectPollTicket = function(params, pollTicket) {
      params.poll_ticket = pollTicket;
      return params;
    };

    /**
     * Takes a list of params and converts them into the braintree format for
     * processing.
     *
     * @param tr_data     {Object} Braintree configuration
     * @param pollTicket  {String} Hash that we use to poll for a response
     * @param params      {Object} Should be a object
     *                                   with the following structure:
     *
     * params = {
     *   amount:
     *   groupitId:
     *   userId:
     *   customer: {},
     *   cc:{},
     *   billing:{}
     * }
     *
     * customer has the following fields:
     *   firstName
     *   lastName
     *   email
     *
     * cc has the following fields:
     *   cardholderName: Must exactly match the name on the card
     *   number
     *   ccv
     *   month
     *   year
     *
     * billing has the following fields:
     *   firstName
     *   lastName
     *   address1 : first line of the address fields
     *   address2: second line of the address fields
     *   locality
     *   region
     *   postalCode
     *   countryCode : Must be in the ISO Standard format
     *   phone
     *
     * We also inject app_key and session token at the base for you
     *
     */
    this.braintreeParams = function(tr_data, pollTicket, params) {
      var map = {};

      function mapIfDefined(key, value) {
        if (!value && value != 0) return;
        map[key] = value
      }

      //Passed via the model
      mapIfDefined("tr_data", tr_data);
      mapIfDefined("transaction[custom_fields][poll_ticket]", pollTicket);
      mapIfDefined("transaction[custom_fields][groupit_id]", params.groupit_id);
      mapIfDefined("transaction[custom_fields][user_id]", params.user_id);
      mapIfDefined("transaction[amount]", params.amount);

      //Framework specified
      mapIfDefined("transaction[custom_fields][app_key]", G.appKey);
      mapIfDefined("transaction[custom_fields][session_token]", G.persistenceToken);

      //Passed as user params
      mapIfDefined("transaction[customer][first_name]", params.customer.firstName);
      mapIfDefined("transaction[customer][last_name]", params.customer.lastName);
      mapIfDefined("transaction[customer][email]", params.customer.email);
      mapIfDefined("transaction[credit_card][cardholder_name]", params.cc.cardholderName);
      mapIfDefined("transaction[credit_card][number]", params.cc.number);
      mapIfDefined("transaction[credit_card][cvv]", params.cc.cvv);
      mapIfDefined("transaction[credit_card][expiration_month]", params.cc.month);
      mapIfDefined("transaction[credit_card][expiration_year]", params.cc.year);
      mapIfDefined("transaction[billing][first_name]", params.billing.firstName);
      mapIfDefined("transaction[billing][last_name]", params.billing.lastName);
      mapIfDefined("transaction[billing][street_address]", params.billing.address1);
      mapIfDefined("transaction[billing][extended_address]", params.billing.address2);
      mapIfDefined("transaction[billing][locality]", params.billing.locality);
      mapIfDefined("transaction[billing][region]", params.billing.region);
      mapIfDefined("transaction[billing][postal_code]", params.billing.postalCode);
      mapIfDefined("transaction[billing][country_code_alpha2]", params.billing.countryCode);
      mapIfDefined("transaction[customer][phone]", params.billing.phone);
      return map;
    }


  }



});/**
 * Copyright (c) 2011 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */


G.provide("", {

  newEmail: function(json) {
    var namespace = G.models.email;
    return G.DataObject.commonConstructor(namespace, G.newEmail, json);
  }

});


G.provide("models.email", {

  objectName: "email",
  path: "/emails",
  keys: ["address", "primary", "user_id", "retail_contact", "id",
    "created_at", "updated_at", "hash_digest"],

  /**
   * Base constructor function for the contribution model
   */
  Base:function() {
    var self = this;

    self.resendVerify = function(config) {
      config = config || {};
      var params = self.data(),
        path = G.models.email.path + "/" +
          (params.id || "undefined") + "/resend_verify";

      params = G.dogfort.injectRailsParams(params);

      G.api(path, "get", params, function(json, xhr) {
        if (xhr.success) {
          if (config.success) config.success(self, xhr);
        } else {
          if (config.error) config.error(json, xhr);
        }
        if (config.complete) config.complete(json, xhr);
      });
    }

  }


});/**
 * Copyright (c) 2011 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("", {
  newGroupit: function(json) {
    var namespace = G.models.groupit;
    return G.DataObject.commonConstructor(namespace, G.newContribution, json);
  }
});

//TODO migrate over to just groupit once we go to restObject
G.provide("models.groupit", {

  //TODO need to do inventory on the keys returned from the server
  objectName: "groupit",
  path: "/groupits",
  keys: ["id", "product_image", "product_url", "product", "price",
    "message", "surprise", "quantity","user_id","recipient", "options",
    "active", "lead_url", "support_url", "purchased", "groupit_type",
    "created_at", "updated_at", "hash_digest", "organizer", "amount_raised"],


  index: function(config) {
    //Testing out the includes directive
    var params = {
      include: ["user","participants","contributions"]
    };

    G.DataObject.commonIndex(config, G.models.groupit, G.newGroupit,
      params, wrapIncludes);

    function wrapIncludes(models) {
      for (var i in models) {
        var j;
        var model = models[i];

        //TODO need to add all these to the keys of a groupit... handle not doing the lookups too..
        //Wrap the user
        if (model.user) {
          model.user(G.newUser(model.user()));
        }

        //Wrap the participants
        if (model.participants) {
          var parts = [];
          for (j in model.participants()) {
            var participant = model.participants()[j];
            //TODO need to get the participant wired with the user
            participant.user = G.newUser(participant.user);
            //TODO FML need those collection attributes
            parts.push(G.newParticipant(participant));
          }
          model.participants(parts);
        }

        //Wrap the contributions
        if (model.contributions) {
          var contrs = [];
          for (j in model.contributions()) {
            var contribution = model.contributions()[j];
            //TODO holy crap clean this
            var user = commonUser(contribution.user_id, model.participants());
            contribution.user = user;
            contrs.push(G.newContribution(model.contributions()[j]));
          }
          model.contributions(contrs);
        }
      }
    }

    //The participants must have a user for the contribution as a contributor => participant
    function commonUser(userId, participants) {
      for (var i in participants) {
        var p = participants[i];
        if (p.userId() == userId) {
          return p.user();
        }
      }
      return null;
    }

  },

  Base: function() {


  }

});/**
 * Copyright (c) 2011 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("", {

  newUser: function(json) {
    var namespace = G.models.user;
    return G.DataObject.commonConstructor(namespace, G.newContribution, json);
  }

});

G.provide("models.user", {

  objectName: "user",
  path: "/users",
  keys: ["name", "login", "organized_before", "is_public", "id", "created_at",
    "updated_at", "name", "password", "persistence_token"], //TODO password really doesn't belong.

  Base: function() {
    var self = this;
    var cookieName = "__groupit__persistenceToken"; //TODO do XD cookies

    //Add the authd key and listeners
    self.extend(["authd"]);
    /**
     * Login is special in that it expects a user object with either the
     * persistenceToken set or the username and password.
     * @param config
     *
     * config is a hash. We support success, and error keys
     */
    self.signin = function(config) {
      config = config || {};
      var path = self.objectPath + "/login" + self.requestType;
      var params = self.data();
      params = self.railify(params, self.objectName);
      params = G.dogfort.injectRailsParams(params);
      G.api(path, "post", params, function(json, xhr) {
        if (xhr.success) {
          json = self.stripNamespace(json, xhr);

          //Setup the cookies
          G.persistenceToken = json.persistence_token;
          G.cookie.setCookie(cookieName, json.persistence_token,
            G.cookie.getExpDate(7, 0, 0), "/");

          //Update the model
          self.extend(json);
          self.authd(true);

          //Let the world know
          if (config.success) config.success(self, xhr);
        } else {
          if (config.error) config.error(json, xhr);
        }
        if (config.complete) config.complete(json, xhr);
      });
    };

    /**
     * Logout resets the persistence token on the server, clears the cookie,
     * and the token stored in memory.
     *
     * @param config
     */

    self.signout = function(config) {
      config = config || {};
      var params = {}, self = this;

      //Clear the persistenceToken from the client.
      G.persistenceToken = null;
      G.cookie.deleteCookie(cookieName, "/");

      //TODO what happens to self? Should we delete everything?
      //Update the model
      self.authd(false);
      //TODO need to get a list of getters and setters or define a clear function
      self.name("");
      self.login("");
      self.persistenceToken("");


      //Tell the server to reset the persistenceToken
      var path = self.objectPath + "/logout" + self.requestType;
      params = G.dogfort.injectRailsParams(params);
      G.api(path, "post", params, function(json, xhr) {
        if (xhr.success) {
          if(config.success) config.success(self, xhr);
        } else {
          if (config.error) config.error(self, xhr);
        }
        if (config.complete) config.complete(json, xhr);
      });
    };

    //Allows client to check for persistenceToken presence
    self.currentPersistenceToken = function() {
      var cookieToken = G.cookie.getCookie(cookieName);
      return G.persistenceToken || cookieToken;
    };


  }

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("polling", {

  /**
   * Creates a unique ticket across all instances of our framework for polling
   */

  uniqueTicket:function() {
    var date = new Date();
    return G.appKey + "" + G.instanceId + "" + date.getTime();
  }

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * Deprecated
 */


G.provide("RestObject", {

  //TODO need to delete this class or fix these references
  persistenceToken: null,
  appSecret:null,

  Base:function(rootPath, objectName) {
    var self = this;
    this.requestType = ".json";
    this.rootPath = rootPath;
    this.objectName = objectName;

    /**
     * Base Index call for all RestObject Objects
     */
    this.index = function(params, callback) {
      var path = rootPath + self.requestType;
      params = self.railify(params);
      params = G.RestObject.injectRailsParams(params);
      G.api(path, "get", params, callback);
    };

    /**
     * Base Create call for all RestObject Objects.
     * Automatically pulls out a singular object from the json response
     */
    this.create = function(params, callback) {
      var path = rootPath + self.requestType;
      params = self.railify(params);
      params = G.RestObject.injectRailsParams(params);
      G.api(path, "post", params, function(json, xhr) {
       if(callback) callback(self.stripNamespace(json, xhr), xhr);
      });
    };

    /**
     * Base Read call for all RestObject Objects
     * Automatically pulls out a singular object from the json response
     * 
     * Undefined is the key word to bypass id based lookup and fallback to
     * other methods like hashes
     */
    this.read = function(params, callback) {
      var path = rootPath + "/" + (params.id || "undefined") + self.requestType;
      params = self.railify(params);
      params = G.RestObject.injectRailsParams(params);
      G.api(path, "get", params, function(json, xhr) {
        if(callback) callback(self.stripNamespace(json, xhr), xhr);
      });
    };

    /**
     * Base Update call for all RestObject Objects.
     * Per rails convention this call updates and doesn't return the updated model
     *
     * Undefined is the key word to bypass id based lookup and fallback to
     * other methods like hashes
     */
    this.update = function(params, callback) {
      var path = rootPath + "/" + (params.id || "undefined") + self.requestType;
      params = self.railify(params);
      params = G.RestObject.injectRailsParams(params);
      G.api(path, "put", params, callback);
    };
    /**
     * Base Destroy call for all RestObject Objects
     *
     * Undefined is the key word to bypass id based lookup and fallback to
     * other methods like hashes
     */
    this.destroy = function(params, callback) {
      var path = rootPath + "/" + (params.id || "undefined") + self.requestType;
      params = self.railify(params);
      params = G.RestObject.injectRailsParams(params);
      G.api(path, "delete", params, callback);
    };

    //Is intended only for framework polling
    this.pollOnce = function(params, callback) {
      var path = rootPath + "/poll" + self.requestType;
      params = self.railify(params);
      params = G.RestObject.injectRailsParams(params);
      G.api(path, "get", params, function(json, xhr) {
        if(callback) callback(self.stripNamespace(json, xhr), xhr);
      });
    };

    /**
     * Rails uses a bracket notation to namespace key-value pairs relating
     * to a model. Example : user[:id] where user is the model name and id is
     * the attribute to be sent to the server.
     */
    this.railify = function(params) {
      var rails_params = {};
      for (var key in params) {
        if (key == "id") continue;
        if (key == "poll_ticket") {
          rails_params[key] = params[key];
          continue;// Need to do a better job here
        }
        rails_params[objectName + "[" + key + "]"] = params[key];
      }
      return rails_params;
    };

    this.stripNamespace = function(json, xhr) {
      return (xhr.success) ? json[objectName] : json;
    };


  },

  /**
   * Injects the session token and app key into the params passed in.
   * @param params {Object} Params going to the server without auth tokens
   *
   */
  injectRailsParams: function(params) {
    params = params || {};

    //Set the token only if we have one and the client didn't set it
    if(!params["user[persistence_token]"] && G.RestObject.persistenceToken){
      params["user[persistence_token]"] = G.RestObject.persistenceToken;  
    }

    params['app_key'] = G.appKey;

    //Should only be used while testing
    if (G.RestObject.appSecret)
      params['app_secret'] = G.RestObject.appSecret;

    if (params['app_secret'] && !G.RestObject.appSecret)
      throw "App secret not set using G.RestObject.appSecret";

    return params;
  },

  injectPollTicket: function(params, pollTicket) {
    params.poll_ticket = pollTicket;
    return params;
  }

});


/**
 * Must be called after RestObject has been defined. Done because each property
 * when initialized by javascript is actually a function execution. Could write
 * this without the load order dependency but this is less code to write
 */
G.provide("", {

  user:function() {

    var base = new G.RestObject.Base("/users", "user");

    //We allow a couple convenience functions for logging in users
    function Override() {
      var self = this;

      //TODO this should not be namespaced, instead it should go to our domain
      //and lookup the current session from there
      var cookieName = "__groupit__persistenceToken";

      /**
       * Login is special in that it expects a user object with either the
       * persistenceToken set or the username and password.
       * @param params
       * @param callback
       */
      this.login = function(params, callback) {
        var path = self.rootPath + "/login" + self.requestType;
        params = self.railify(params, self.objectName);
        params = G.RestObject.injectRailsParams(params);
        G.api(path, "post", params, function(json, xhr) {
          json = self.stripNamespace(json, xhr);
          if (xhr.success) {
            G.RestObject.persistenceToken = json.persistence_token;
            G.cookie.setCookie(cookieName, json.persistence_token,
              G.cookie.getExpDate(7, 0, 0), "/");
          }

         if(callback) callback(json, xhr);
        });
      };

      this.logout = function(callback) {
        var params = {}, self = this;

        //Clear the persistenceToken from the client.
        G.RestObject.persistenceToken = null;
        G.cookie.deleteCookie(cookieName, "/");

        //Tell the server to reset the persistenceToken
        var path = self.rootPath + "/logout" + self.requestType;
        params = self.railify(params, self.objectName);
        params = G.RestObject.injectRailsParams(params);
        G.api(path, "post", params, function(json, xhr) {
          if(callback) callback(json, xhr);
        });
      };

      this.currentPersistenceToken = function() {
        var cookieToken = G.cookie.getCookie("__groupit__persistenceToken");
        return G.RestObject.persistenceToken || cookieToken;
      };


      this.isLoggedIn = function() {
        return !!G.RestObject.persistenceToken
      };
    }

    Override.prototype = base;
    return new Override();

  }(),

  paymentResponse:function() {
    return new G.RestObject.Base("/payment_responses", "payment_response");
  }(),

  groupit:function() {
    return new G.RestObject.Base("/groupits", "groupit");
  }(),

  participant:function() {
    return new G.RestObject.Base("/participants", "participant");
  }(),

  note:function() {
    return new G.RestObject.Base("/notes", "note");
  }(),

  feedPost:function() {
    return new G.RestObject.Base("/feed_posts", "feed_post");
  }(),

  email:function() {
    return new G.RestObject.Base("/emails", "email");
  }(),

  authentication:function() {
    return new G.RestObject.Base("/authentications", "authentication");
  }(),

  app:function() {
    return new G.RestObject.Base("/apps", "app");
  }(),

  address:function() {
    return new G.RestObject.Base("/addresses", "address");
  }(),

  //Facades Follow
  invitee:function() {
    var base = new G.RestObject.Base("/invitees", "invitee");

    function Override() {
      delete this.update;
      delete this.read;
      delete this.index;
      delete this.destroy;
    }

    Override.prototype = base;
    return new Override();
  }()

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

G.provide("", {
  route:function(hash, callback) {
    G.router.route.call(G.router, hash, callback);
  }
});

G.provide("router", {

  routes: {},

  init:function() {
    G.addEvent(window, 'hashchange', G.router.execRoute);
  },

  route:function(hashName, callback) {
    G.router.routes[hashName] = callback;
  },

  execRoute:function() {
    var hash = window.location.hash.slice(1),
      urlParams = hash.split("/"),
      name = urlParams.shift();
    var callback = G.router.routes[name];
    if (!callback) callback = G.router.routes["*"];
    if (callback) callback(name, urlParams);
  }

});

//Gets called at framework runtime
//(function() {

//  backup if hashchange event is not supported for ie7 (bah! FUCKING IE)
//  if(G.browser.ieVersion() < 8){
//    var ieFrame = document.createElement("iframe");
//    var prevHash = null;
//    setInterval(function(){
//      if(window.location.hash != prevHash){
//        G.router.execRoute();
//        prevHash = window.location.hash;
//      }
//    }, 150);
//  }

//})();
/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING fromWidget, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * Provides basic support for transitioning between components.
 */
G.provide("", {
  newTransitionMap:function() {
    return new G.transition.Base();
  }
});


G.provide("transition", {

  Base:function() {
    var transitions = {};

    this.addTransitions = function(transObj) {
      G.copy(transitions, transObj, true);
    };

    this.trigger = function(fromWidget, toWidget, urlParams) {
      var fn;
      if (!toWidget) throw("G.transition.trigger: Must go somewhere with toWidget");
      if (!fromWidget || fromWidget == toWidget) { //Treating refresh as same as initial load
        fn = transitions[toWidget.name];
        if (fn) fn(toWidget, urlParams);
      } else {
        fn = transitions[fromWidget.name + "_" + toWidget.name];
        if (fn) fn(fromWidget, toWidget, urlParams);
      }
    };
  }


});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING fromWidget, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 *
 * This module is deprecated 
 *
 */

/**
 * Basic object with observers for all attributes
 *
 */
G.provide("", {
  newViewModel: function(defaults) {
    var base = new G.ViewModel.Base();
    base.set(defaults);
    return base;
  }
});


G.provide("ViewModel", {

  Base:function() {

    var self = this;
    var data = {};
    var listeners = {};

    this.get = function(key) {
//      G.log("Get is Deprecated");
      return data[key];
    };

    this.set = function(key, value) {
//      G.log("Set is Deprecated");
      _set(key, value, true);
    };

    this.bind = function(key, context, fn) {
//      G.log("Bind is Deprecated");
      listeners[key] = listeners[key] || [];
      var listener = {
        fn:fn,
        context:context
      };
      //Ensure no duplicates are created on accident
      self.unbind(key, context, fn);
      listeners[key].push(listener);
    };

    this.unbind = function(key, context, fn) {
      listeners[key] = listeners[key] || [];
      for (var i = 0,len = listeners[key].length; i < len; ++i) {
        var listener = listeners[key][i];
        if (listener.fn == fn && listener.context == context) {
          listeners[key].splice(i, 1);
        }
      }
    };

    this.updateOnly = function(key, value) {
      _set(key, value, false);
    };

    this.debug = function() {
      G.log(data);
      G.log(listeners);
    };

    /**
     *  Copies key value pairs into data. If a object is provided as a key
     *  then we disregard the value and recursively call _set until all the
     *  keys have been transversed.
     *
     * @param key
     * @param value
     * @param create {Boolean} If false setting will not create records (only update)
     */
    function _set(key, value, create) {
      listeners[key] = listeners[key] || [];
      if (typeof key === 'object') {
        var obj = key;
        for (var k in obj) {
          self.set(k, obj[k], create);
        }
      } else {
        //Need to think about cycles where the data is incremented on each touch
        if ((!create && key in data) || create) {
          data[key] = value;
        }
        for (var i in listeners[key]) {
          var listener = listeners[key][i];
//          G.log("--Event Listener on key: "+key+" Fired--");
//          G.log(listener.context);
          listener.fn.apply(listener.context, [value]);
        }
      }
    }

  }

});/**
 * Copyright (c) 2010 Timothy Cardenas
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 * @provides G.pages G.widget
 * @requires G.provide G.ApiClient
 *
 */


/**
 * widget.js
 * Exposes api for manipulating
 *
 */

G.provide("", {
  require: function() {
    return G.widget.require.apply(G.widget, arguments);
  },

  newWidget:function() {
    return G.widget.instance.apply(G.widget, arguments);
  },

  register:function() {
    return G.widget.register.apply(G.widget, arguments);
  }

});

G.provide("widget", {

  constructors: {},
  html:{},

  /**
   * Base constructor for all Widget instances
   */
  Base: function(name, widgetType) {

    this.name = name;
    this._html = G.widget.html[widgetType];
    this.rootNode = initRootNode();

    function initRootNode() {
      var div = document.createElement("div"); //garbage collected automatically
      div.innerHTML = G.widget.html[widgetType];
      return div;
    }

    this.hashOnAttribute = function(hash, attr) {
      var elems = this.rootNode.getElementsByTagName("*");
      for (var i in elems) {
        var elem = elems[i], pid;
        if (!!elem.getAttribute && !!(pid = elem.getAttribute(attr))) {
          hash[pid] = elem;
        }
      }
    };

    this.preventDefault = function(e) {
      if (!e) {
        return;
      }

      //Everyone else support for canceling events
      if (e.preventDefault) {
        e.preventDefault();
      }

      //IE support for canceling events
      e.returnValue = false;
    };


    this.detach = function() {
      var parent = this.rootNode.parentNode;
      if (parent) parent.removeChild(this.rootNode);
    };

  },

  /**
   * Creates a instance of our widget
   * @param name {String} The name of the instance, used for transitions etc
   * @param widgetType {String} The widget type declared with register
   * @param instanceObject {Object}[Optional] Extends instance with this obj
   */
  instance:function(name, widgetType, instanceObject) {

    if (!G.widget.constructors[widgetType]) {
      throw("G.widget.instance called on null constructor. (" + widgetType + ")");
    }
    if (!name) {
      throw("G.widget.instance called without a instance name");
    }

    var instance;
    (function(realG) { //could limit access to G if needed
      var pids = {}, base;

      //Forces page constructor to be lexicaly bound to our current context
      //instead of iframe (current context should be current closure and
      //then main page closure)
      eval("var " + widgetType + " = " + G.widget.constructors[widgetType].toString() + ";");
//    eval("fn = " + G.widget.constructors[widgetType].toString() + ";");

      //By default hash all elems with a pid for quick lookup later
      //pids hash avail in page (looks like global) but is just bound
      //in that page. (<3 closures). Do before instance is created so
      //pids hash can be referenced during instantiation.
      base = new realG.widget.Base(name, widgetType);
      eval(widgetType + ".prototype = base");
//      fn.prototype = base;
      base.hashOnAttribute(pids, "pid");

      eval("instance = new " + widgetType + "()");
//      instance = new fn();
      //Adds the instance data into the instance overwriting if necessary
      if (instanceObject) {
        G.copy(instance, instanceObject, true);
      }

      function S(selector) {
        if (jQuery) {
          return jQuery(base.rootNode).find(selector);
        }
      }

    })(G);

    return instance;
  },

  register: function(widgetType, pageConstructor) {

    if (typeof pageConstructor != "function") {
      throw("Fatal: G.widget.register only takes a constructor function as a argument");
    }

    G.widget.constructors[widgetType] = pageConstructor;
  },

  require:function(path, widgetType) {
    G.widget.require.pages = G.Page.require.pages || {};

    widgetType = widgetType || G.widget.pathToName(path);

    //No Op when the page has already been required
    if (G.widget.require.pages[widgetType]) {
      return;
    }

    G.widget.require.pages[widgetType] = widgetType;


    if (!G.widget.constructors[widgetType]) {
      G.widget.fetch(path, widgetType);
    }

  },

  ready:function(widgetTypes, callback) {
    var intervalId,
      timeWaiting = 0,
      interval = 50;

    intervalId = setInterval(function() {
      timeWaiting += interval
      if (timeWaiting > 1000) {
        G.log("G.widget.ready waiting over a second for ready state.");
        timeWaiting = 0;
      }

      for (var i in widgetTypes) {
        var widgetType = widgetTypes[i];
        if (!G.widget.constructors[widgetType]) {
          return;
        }
      }
      clearInterval(intervalId);

      callback();

    }, interval);
  },

  fetch: function() {
    var args = Array.prototype.slice.call(arguments),
      path = args.shift(),
      next = args.shift(),
      widgetType,
      callback;

    while (next) {
      var type = typeof next;

      if (type === 'string' && !widgetType) {
        widgetType = next;
      } else if (type === 'function' && !callback) {
        callback = next;
      }
      else {
        G.log('Invalid argument passed to G.widget.fetch(): ' + next);
        return;
      }
      next = args.shift();
    }


    //Default widgetType will be the route to it with / replaced with undescores
    widgetType = widgetType || G.widget.pathToName(path);

    G.widget.fetchRequest(path, widgetType, callback);
  },

  pathToName:function(path) {
    return path.replace(/\//g, "_");
  },


  /**
   *
   */

  fetchRequest: function(path, widgetType, callback) {

    //Preamble = dirty magic to pull references into iframe,
    //couples js with controller :(
    var preamble = "<script>window.G = top." + globalName + ";</script>";

    G.ApiClient.rest('widgets/show', 'get', {
      path: path,
      preamble: preamble,
      page_name: widgetType
    }, function(html) {

      if (!!callback) {
        callback(G.widget.constructors[widgetType]);
      }
    });
  }
});

})(window);